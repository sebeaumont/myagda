#+TITLE:     Isomorphism
#+SETUPFILE: org-source-setup.org

* Preamble

As usual we eat our own dogfood as much as possible.

#+begin_src agda2
open import Naturals
open import Equality
open Equality.â‰¡-Reasoning
#+end_src

* Function Composition

#+begin_src agda2
_âˆ˜_ : âˆ€ {A B C : Set} â†’ (B â†’ C) â†’ (A â†’ B) â†’ (A â†’ C)
g âˆ˜ f = Î» x â†’ g (f x)
#+end_src

* Extensionality

This is the converse of =cong-app= as we saw in the earlier [[file:Equality.lagda.org][definition]]

We can't prove extensionality as a theorem in MLTT[fn:1] and thereby
hangs a tale of great significance. We can assert it an an axiom.


#+begin_src agda2
postulate
  extensionality : âˆ€ {A B : Set} {f g : A â†’ B}
    â†’ (âˆ€ (x : A) â†’ f x â‰¡ g x)
      -----------------------
    â†’ f â‰¡ g
#+end_src

In cubical Agda we can prove functional extensionality and thus it becomes
theorem:

#+begin_src agda
funExt : {f g : A â†’ B} â†’ (p : (x : A) â†’ f x â‰¡ g x) â†’ f â‰¡ g
funExt p i x = p x i
#+end_src

Postulating extentionality in Agda/MLTT is ok according to the PLFA
authors as this /axiom/ is consistent with the intuitionistic type theory
and constructively does not affect computation.

We can use this when we can show that functions always return the same
result; consider an addition operator defined the other way round to +:

#+begin_src agda2
_+'_ : â„• â†’ â„• â†’ â„•
m +' zero = m
m +' suc n = suc (m +' n)
#+end_src

Applying commutativity, it is easy to show that both operators always
return the same result given the same arguments: (so is this an instance
of the proof I wanted?) We have an equality proof of commuativity of
addition by induction over ğ which we can use here.

[[id:80C26F92-669C-48C5-8247-F9EF51EC331B][Agda Notes]] (on rewrite/with abstraction)

#+begin_src agda2
same-by-app : âˆ€ (m n : â„•) â†’ m +' n â‰¡ m + n
same-by-app m n rewrite +-comm m n = helper m n
  where
  helper : âˆ€ (m n : â„•) â†’ m +' n â‰¡ n + m
  helper m zero = refl
  helper m (suc n) = cong suc (helper m n)
#+end_src

We can however assert via extensionality that the two operators are actually
indistinguishable:

#+begin_src agda2
same : _+'_ â‰¡ _+_
same = extensionality (Î» m â†’ extensionality (Î» n â†’ same-by-app m n))
#+end_src

We need to postulate extensionality for dependent functions:

#+begin_src agda2
postulate 
  Î -extensionality : âˆ€ {A : Set} {B : A â†’ Set} {f g : âˆ€ (x : A) â†’ B x}
    â†’ (âˆ€ (x : A) â†’ f x â‰¡ g x)
      ----------------------
    â†’ f â‰¡ g
#+end_src


* Isomorphism

Two types (Sets) are isomorphic if they are in one-to-one
correspondance.

** â‰ƒ Isomorphism

#+begin_src agda2
infix 0 _â‰ƒ_
record _â‰ƒ_ (A B : Set) : Set where
  field
    to : A â†’ B
    from : B â†’ A
    fromâˆ˜to : âˆ€ (x : A) â†’ from (to x) â‰¡ x
    toâˆ˜from : âˆ€ (y : B) â†’ to (from y) â‰¡ y
open _â‰ƒ_
#+end_src

To prove that Isomorphism is an equivalence relation we need to provide proofs
of reflexivity, symmetry and transitivity in the usual way:

** â‰ƒ is reflexive

#+begin_src agda2
â‰ƒ-refl : âˆ€ {A : Set}
    -----
  â†’ A â‰ƒ A
â‰ƒ-refl .to = Î» z â†’ z
â‰ƒ-refl .from = Î» z â†’ z
â‰ƒ-refl .fromâˆ˜to = Î» x â†’ refl
â‰ƒ-refl .toâˆ˜from = Î» y â†’ refl
#+end_src

** â‰ƒ is symmetric

To show that isomorhism is symmetric we simply swap the roles of the
functions above:

#+begin_src agda2
â‰ƒ-sym : âˆ€ {A B : Set}
  â†’ A â‰ƒ B
    -----
  â†’ B â‰ƒ A
â‰ƒ-sym Aâ‰ƒB .to = Aâ‰ƒB .from
â‰ƒ-sym Aâ‰ƒB .from = Aâ‰ƒB .to
â‰ƒ-sym Aâ‰ƒB .fromâˆ˜to = toâˆ˜from Aâ‰ƒB 
â‰ƒ-sym Aâ‰ƒB .toâˆ˜from = fromâˆ˜to Aâ‰ƒB
#+end_src

** â‰ƒ is transitive

To show that isomorohism is transtive we compose the =to= and =from= functions
and use equational reasoning to combine the inverses:

#+begin_src agda2
â‰ƒ-trans : âˆ€ {A B C : Set}
  â†’ A â‰ƒ B
  â†’ B â‰ƒ C
    -----
  â†’ A â‰ƒ C
â‰ƒ-trans Aâ‰ƒB Bâ‰ƒC =
  record
    { to       = to Bâ‰ƒC âˆ˜ to Aâ‰ƒB
    ; from   = from Aâ‰ƒB âˆ˜ from Bâ‰ƒC
    ; fromâˆ˜to = Î»{x â†’
        begin
          (from Aâ‰ƒB âˆ˜ from Bâ‰ƒC) ((to Bâ‰ƒC âˆ˜ to Aâ‰ƒB) x)
        â‰¡âŸ¨âŸ©
          from Aâ‰ƒB (from Bâ‰ƒC (to Bâ‰ƒC (to Aâ‰ƒB x)))
        â‰¡âŸ¨ cong (from Aâ‰ƒB) (fromâˆ˜to Bâ‰ƒC (to Aâ‰ƒB x)) âŸ©
          from Aâ‰ƒB (to Aâ‰ƒB x)
        â‰¡âŸ¨ fromâˆ˜to Aâ‰ƒB x âŸ©
          x
        âˆ}
    ; toâˆ˜from = Î»{y â†’
        begin
          (to Bâ‰ƒC âˆ˜ to Aâ‰ƒB) ((from Aâ‰ƒB âˆ˜ from Bâ‰ƒC) y)
        â‰¡âŸ¨âŸ©
          to Bâ‰ƒC (to Aâ‰ƒB (from Aâ‰ƒB (from Bâ‰ƒC y)))
        â‰¡âŸ¨ cong (to Bâ‰ƒC) (toâˆ˜from Aâ‰ƒB (from Bâ‰ƒC y)) âŸ©
          to Bâ‰ƒC (from Bâ‰ƒC y)
        â‰¡âŸ¨ toâˆ˜from Bâ‰ƒC y âŸ©
          y
        âˆ}
      }
#+end_src

We can now add syntax for equational reasoning via isomorphism.

#+begin_src agda2
module â‰ƒ-Reasoning where

  infix  1 â‰ƒ-begin_
  infixr 2 _â‰ƒâŸ¨_âŸ©_
  infix  3 _â‰ƒ-âˆ

  â‰ƒ-begin_ : âˆ€ {A B : Set}
    â†’ A â‰ƒ B
      -----
    â†’ A â‰ƒ B
  â‰ƒ-begin Aâ‰ƒB = Aâ‰ƒB

  _â‰ƒâŸ¨_âŸ©_ : âˆ€ (A : Set) {B C : Set}
    â†’ A â‰ƒ B
    â†’ B â‰ƒ C
      -----
    â†’ A â‰ƒ C
  A â‰ƒâŸ¨ Aâ‰ƒB âŸ© Bâ‰ƒC = â‰ƒ-trans Aâ‰ƒB Bâ‰ƒC

  _â‰ƒ-âˆ : âˆ€ (A : Set)
      -----
    â†’ A â‰ƒ A
  A â‰ƒ-âˆ = â‰ƒ-refl
#+end_src

* Embedding

Embedding is a weakening of isomorphism that shows that the first type is
included in the second but that the second type is in many-to-one correspondence
with the first.

** âˆ¼< is embedding
#+begin_src agda2
infix 0 _â‰²_
record _â‰²_ (A B : Set) : Set where
    field
      to   : A â†’ B
      from : B â†’ A
      fromâˆ˜to : âˆ€ (x : A) â†’ from (to x) â‰¡ x
open _â‰²_
#+end_src

Embedding is reflexive and transitive, but not symmetric, however like orderings there
is a notion of antisymmetry:

** âˆ¼< is reflexive
#+begin_src agda2
â‰²-refl : âˆ€ {A : Set} â†’ A â‰² A
â‰²-refl =
  record
    { to      = Î»{x â†’ x}
    ; from    = Î»{y â†’ y}
    ; fromâˆ˜to = Î»{x â†’ refl}
    }
#+end_src

** âˆ¼< is transitive
#+begin_src agda2
â‰²-trans : âˆ€ {A B C : Set} â†’ A â‰² B â†’ B â‰² C â†’ A â‰² C
â‰²-trans Aâ‰²B Bâ‰²C =
  record
    { to      = Î»{x â†’ to   Bâ‰²C (to   Aâ‰²B x)}
    ; from    = Î»{y â†’ from Aâ‰²B (from Bâ‰²C y)}
    ; fromâˆ˜to = Î»{x â†’
        begin
          from Aâ‰²B (from Bâ‰²C (to Bâ‰²C (to Aâ‰²B x)))
        â‰¡âŸ¨ cong (from Aâ‰²B) (fromâˆ˜to Bâ‰²C (to Aâ‰²B x)) âŸ©
          from Aâ‰²B (to Aâ‰²B x)
        â‰¡âŸ¨ fromâˆ˜to Aâ‰²B x âŸ©
          x
        âˆ}
    }
#+end_src

** âˆ¼< is weakly anti-symmetric
So here is the weak form of anti-symmetry that shows if A embeds in B and B
embeds in A then they are isomorphic.

#+begin_src agda2
â‰²-antisym : âˆ€ {A B : Set}
  â†’ (Aâ‰²B : A â‰² B)
  â†’ (Bâ‰²A : B â‰² A)
  â†’ (to Aâ‰²B â‰¡ from Bâ‰²A)
  â†’ (from Aâ‰²B â‰¡ to Bâ‰²A)
    -------------------
  â†’ A â‰ƒ B
â‰²-antisym Aâ‰²B Bâ‰²A toâ‰¡from fromâ‰¡to =
  record
    { to      = to Aâ‰²B
    ; from    = from Aâ‰²B
    ; fromâˆ˜to = fromâˆ˜to Aâ‰²B
    ; toâˆ˜from = Î»{y â†’
        begin
          to Aâ‰²B (from Aâ‰²B y)
        â‰¡âŸ¨ cong (to Aâ‰²B) (cong-app fromâ‰¡to y) âŸ©
          to Aâ‰²B (to Bâ‰²A y)
        â‰¡âŸ¨ cong-app toâ‰¡from (to Bâ‰²A y) âŸ©
          from Bâ‰²A (to Bâ‰²A y)
        â‰¡âŸ¨ fromâˆ˜to Bâ‰²A y âŸ©
          y
        âˆ}
    }
#+end_src

** Equational reasoning for embedding

#+begin_src agda2
module â‰²-Reasoning where

  infix  1 â‰²-begin_
  infixr 2 _â‰²âŸ¨_âŸ©_
  infix  3 _â‰²-âˆ

  â‰²-begin_ : âˆ€ {A B : Set}
    â†’ A â‰² B
      -----
    â†’ A â‰² B
  â‰²-begin Aâ‰²B = Aâ‰²B

  _â‰²âŸ¨_âŸ©_ : âˆ€ (A : Set) {B C : Set}
    â†’ A â‰² B
    â†’ B â‰² C
      -----
    â†’ A â‰² C
  A â‰²âŸ¨ Aâ‰²B âŸ© Bâ‰²C = â‰²-trans Aâ‰²B Bâ‰²C

  _â‰²-âˆ : âˆ€ (A : Set)
      -----
    â†’ A â‰² A
  A â‰²-âˆ = â‰²-refl
#+end_src

* Iso-morhism implies an embedding
#+begin_src agda2
â‰ƒ-implies-â‰² : âˆ€ {A B : Set}
  â†’ A â‰ƒ B
    -----
  â†’ A â‰² B
â‰ƒ-implies-â‰² Aâ‰ƒB =
  record
    { to = to Aâ‰ƒB
      ; from = from Aâ‰ƒB
      ; fromâˆ˜to = fromâˆ˜to Aâ‰ƒB
      }
#+end_src

* Equivalence
** â‡” is iff or equivalence 
#+begin_src agda2
record _â‡”_ (A B : Set) : Set where
  field
    to : A â†’ B
    from : B â†’ A
open _â‡”_
#+end_src

So now to prove that equivalence is an equivalence relation
(it had better be eh?)

** â‡” is reflexive
#+begin_src agda2
â‡”-refl : {A : Set}
  â†’ A â‡” A
â‡”-refl =
  record
    { to = Î»{a â†’ a}
    ; from = Î»{b â†’ b}
    }
#+end_src

** â‡” is symmetric
#+begin_src agda2
â‡”-sym : {A B : Set}
  â†’ A â‡” B
    -----
  â†’ B â‡” A
â‡”-sym Aâ‡”B =
  record
    { to = from Aâ‡”B
    ; from = to Aâ‡”B
    }
#+end_src

** â‡” is transitive
#+begin_src agda2
â‡”-trans : {A B C : Set}
  â†’ A â‡” B
  â†’ B â‡” C
    ------
  â†’ A â‡” C
â‡”-trans Aâ‡”B Bâ‡”C =
  record
    { to = (to Bâ‡”C) âˆ˜ (to Aâ‡”B)
    ; from = (from Aâ‡”B) âˆ˜ (from Bâ‡”C)
    }
#+end_src
âˆ

* Footnotes

[fn:1] Why can't we do this? What are the issues? Axioms make me nervous and
we can't use ={-# OPTIONS --safe #-}=.
