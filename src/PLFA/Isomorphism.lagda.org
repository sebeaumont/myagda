#+TITLE:     Isomorphism
#+SETUPFILE: org-source-setup.org

* Agda Module

#+begin_src agda2
module PLFA.Isomorphism where

import PLFA.Naturals as Nats
open Nats

import PLFA.Equality as Eq
open Eq
open Eq.â‰¡-Reasoning
#+end_src

* Function Composition

#+begin_src agda2
_âˆ˜_ : âˆ€ {A B C : Set} â†’ (B â†’ C) â†’ (A â†’ B) â†’ (A â†’ C)
g âˆ˜ f = Î» x â†’ g (f x)
#+end_src

* Extensionality

This is the converse of =cong-app= as we saw in the earlier [[file:PLFA.Equality.html][definition]]

We can't prove extensionality as a theorem in MLTT[fn:1] and thereby
hangs a tale of great significance. We have to assert it as an axiom.


#+begin_src agda2
postulate
  extensionality : âˆ€ {A B : Set} {f g : A â†’ B}
    â†’ (âˆ€ (x : A) â†’ f x â‰¡ g x)
      -----------------------
    â†’ f â‰¡ g
#+end_src

In cubical Agda we can prove functional extensionality and thus it becomes
theorem. This is beacause we no longer us an inductive defintion of
propositional equality in the "types as spaces" theories with hompotopy
levels, indeed in HoTT types are modelled as =âˆ-groupoids=.

#+begin_src agda-cubical
funExt : {f g : A â†’ B} â†’ (p : (x : A) â†’ f x â‰¡ g x) â†’ f â‰¡ g
funExt p i x = p x i
#+end_src

Postulating extentionality in Agda/MLTT is ok according to the PLFA
authors as this /axiom/ is consistent with the intuitionistic type theory
and constructively does not affect computation.[fn:3]

We can use this when we can show that functions always return the same
result; consider an addition operator =+'= defined by induction on the
second argument.

#+begin_src agda2
_+'_ : â„• â†’ â„• â†’ â„•
m +' zero = m
m +' suc n = suc (m +' n)
#+end_src

Applying commutativity, it is easy to show that both operators always
return the same result given the same arguments. We have an equality proof
of commuativity of addition by induction over ğ which we can use here.

[[id:80C26F92-669C-48C5-8247-F9EF51EC331B][Agda Notes]] (on rewrite/with abstraction)

#+begin_src agda2
same-by-app : âˆ€ (m n : â„•) â†’ m +' n â‰¡ m + n
same-by-app m n rewrite +-comm m n = helper m n
  where
  helper : âˆ€ (m n : â„•) â†’ m +' n â‰¡ n + m
  helper m zero = refl
  helper m (suc n) = cong suc (helper m n)
#+end_src

We can show, via extensionality, that the two operators are actually
indistinguishable:

#+begin_src agda2
same : _+'_ â‰¡ _+_
same = extensionality (Î» m â†’ extensionality (Î» n â†’ same-by-app m n))
#+end_src

We also need to postulate extensionality for dependent functions:

#+begin_src agda2
postulate 
  Î -extensionality : âˆ€ {A : Set} {B : A â†’ Set} {f g : âˆ€ (x : A) â†’ B x}
    â†’ (âˆ€ (x : A) â†’ f x â‰¡ g x)
      ----------------------
    â†’ f â‰¡ g
#+end_src

* Isomorphism

Two types (Sets) are isomorphic if they are in one-to-one
correspondance.

** â‰ƒ Isomorphism

#+begin_src agda2
infix 0 _â‰ƒ_
record _â‰ƒ_ (A B : Set) : Set where
  field
    to : A â†’ B
    from : B â†’ A
    fromâˆ˜to : âˆ€ (x : A) â†’ from (to x) â‰¡ x
    toâˆ˜from : âˆ€ (y : B) â†’ to (from y) â‰¡ y
open _â‰ƒ_
#+end_src

To prove that Isomorphism is an equivalence relation we need to provide proofs
of reflexivity, symmetry and transitivity in the usual way[fn:2]:

** â‰ƒ is reflexive 

#+begin_src agda2
â‰ƒ-refl : âˆ€ {A : Set}
    -----
  â†’ A â‰ƒ A
â‰ƒ-refl .to      = Î» x â†’ x
â‰ƒ-refl .from    = Î» x â†’ x
â‰ƒ-refl .fromâˆ˜to = Î» x â†’ refl
â‰ƒ-refl .toâˆ˜from = Î» y â†’ refl
#+end_src

** â‰ƒ is symmetric
To show that isomorhism is symmetric we simply swap the roles of the
functions above:

#+begin_src agda2
â‰ƒ-sym : âˆ€ {A B : Set}
  â†’ A â‰ƒ B
    -----
  â†’ B â‰ƒ A
â‰ƒ-sym Aâ‰ƒB .to      = Aâ‰ƒB .from
â‰ƒ-sym Aâ‰ƒB .from    = Aâ‰ƒB .to
â‰ƒ-sym Aâ‰ƒB .fromâˆ˜to = toâˆ˜from Aâ‰ƒB 
â‰ƒ-sym Aâ‰ƒB .toâˆ˜from = fromâˆ˜to Aâ‰ƒB
#+end_src

** â‰ƒ is transitive

To show that isomorphism is transtive we compose the =to= and =from= functions
and use equational reasoning to combine the inverses:

#+begin_src agda2
â‰ƒ-trans : âˆ€ {A B C : Set}
  â†’ A â‰ƒ B
  â†’ B â‰ƒ C
    -----
  â†’ A â‰ƒ C
â‰ƒ-trans Aâ‰ƒB Bâ‰ƒC .to      = to Bâ‰ƒC âˆ˜ to Aâ‰ƒB 
â‰ƒ-trans Aâ‰ƒB Bâ‰ƒC .from    = from Aâ‰ƒB âˆ˜ from Bâ‰ƒC
â‰ƒ-trans Aâ‰ƒB Bâ‰ƒC .fromâˆ˜to = Î» x â†’
                           begin
                             (from Aâ‰ƒB âˆ˜ from Bâ‰ƒC) ((to Bâ‰ƒC âˆ˜ to Aâ‰ƒB) x)
                           â‰¡âŸ¨âŸ©
                             from Aâ‰ƒB (from Bâ‰ƒC (to Bâ‰ƒC (to Aâ‰ƒB x)))
                           â‰¡âŸ¨ cong (from Aâ‰ƒB) (fromâˆ˜to Bâ‰ƒC (to Aâ‰ƒB x)) âŸ©
                             from Aâ‰ƒB (to Aâ‰ƒB x)
                           â‰¡âŸ¨ fromâˆ˜to Aâ‰ƒB x âŸ©
                             x
                           âˆ
â‰ƒ-trans Aâ‰ƒB Bâ‰ƒC .toâˆ˜from = Î» y â†’
                           begin
                             (to Bâ‰ƒC âˆ˜ to Aâ‰ƒB) ((from Aâ‰ƒB âˆ˜ from Bâ‰ƒC) y)
                           â‰¡âŸ¨âŸ©
                           to Bâ‰ƒC (to Aâ‰ƒB (from Aâ‰ƒB (from Bâ‰ƒC y)))
                           â‰¡âŸ¨ cong (to Bâ‰ƒC) (toâˆ˜from Aâ‰ƒB (from Bâ‰ƒC y)) âŸ©
                             to Bâ‰ƒC (from Bâ‰ƒC y)
                           â‰¡âŸ¨ toâˆ˜from Bâ‰ƒC y âŸ©
                             y
                           âˆ
#+end_src



We can now add syntax for equational reasoning via isomorphism.

#+begin_src agda2
module â‰ƒ-Reasoning where

  infix  1 â‰ƒ-begin_
  infixr 2 _â‰ƒâŸ¨_âŸ©_
  infix  3 _â‰ƒ-âˆ

  â‰ƒ-begin_ : âˆ€ {A B : Set}
    â†’ A â‰ƒ B
      -----
    â†’ A â‰ƒ B
  â‰ƒ-begin Aâ‰ƒB = Aâ‰ƒB

  _â‰ƒâŸ¨_âŸ©_ : âˆ€ (A : Set) {B C : Set}
    â†’ A â‰ƒ B
    â†’ B â‰ƒ C
      -----
    â†’ A â‰ƒ C
  A â‰ƒâŸ¨ Aâ‰ƒB âŸ© Bâ‰ƒC = â‰ƒ-trans Aâ‰ƒB Bâ‰ƒC

  _â‰ƒ-âˆ : âˆ€ (A : Set)
      -----
    â†’ A â‰ƒ A
  A â‰ƒ-âˆ = â‰ƒ-refl
#+end_src

* Embedding

Embedding is a weakening of isomorphism that shows that the first type is
included in the second but that the second type is in many-to-one correspondence
with the first.

** â‰² is embedding
#+begin_src agda2
infix 0 _â‰²_
record _â‰²_ (A B : Set) : Set where
    field
      to   : A â†’ B
      from : B â†’ A
      fromâˆ˜to : âˆ€ (x : A) â†’ from (to x) â‰¡ x
open _â‰²_
#+end_src

Embedding is reflexive and transitive, but not symmetric, however like orderings there
is a notion of antisymmetry:

** â‰² is reflexive
#+begin_src agda2
â‰²-refl : âˆ€ {A : Set} â†’ A â‰² A
â‰²-refl =
  record
    { to      = Î»{x â†’ x}
    ; from    = Î»{y â†’ y}
    ; fromâˆ˜to = Î»{x â†’ refl}
    }
#+end_src

** â‰² is transitive
#+begin_src agda2
â‰²-trans : âˆ€ {A B C : Set} â†’ A â‰² B â†’ B â‰² C â†’ A â‰² C
â‰²-trans Aâ‰²B Bâ‰²C =
  record
    { to      = Î»{x â†’ to   Bâ‰²C (to   Aâ‰²B x)}
    ; from    = Î»{y â†’ from Aâ‰²B (from Bâ‰²C y)}
    ; fromâˆ˜to = Î»{x â†’
        begin
          from Aâ‰²B (from Bâ‰²C (to Bâ‰²C (to Aâ‰²B x)))
        â‰¡âŸ¨ cong (from Aâ‰²B) (fromâˆ˜to Bâ‰²C (to Aâ‰²B x)) âŸ©
          from Aâ‰²B (to Aâ‰²B x)
        â‰¡âŸ¨ fromâˆ˜to Aâ‰²B x âŸ©
          x
        âˆ}
    }
#+end_src

** â‰² is weakly anti-symmetric
So here is the weak form of anti-symmetry that shows if A embeds in B and B
embeds in A then they are isomorphic.

#+begin_src agda2
â‰²-antisym : âˆ€ {A B : Set}
  â†’ (Aâ‰²B : A â‰² B)
  â†’ (Bâ‰²A : B â‰² A)
  â†’ (to Aâ‰²B â‰¡ from Bâ‰²A)
  â†’ (from Aâ‰²B â‰¡ to Bâ‰²A)
    -------------------
  â†’ A â‰ƒ B
â‰²-antisym Aâ‰²B Bâ‰²A toâ‰¡from fromâ‰¡to =
  record
    { to      = to Aâ‰²B
    ; from    = from Aâ‰²B
    ; fromâˆ˜to = fromâˆ˜to Aâ‰²B
    ; toâˆ˜from = Î»{y â†’
        begin
          to Aâ‰²B (from Aâ‰²B y)
        â‰¡âŸ¨ cong (to Aâ‰²B) (cong-app fromâ‰¡to y) âŸ©
          to Aâ‰²B (to Bâ‰²A y)
        â‰¡âŸ¨ cong-app toâ‰¡from (to Bâ‰²A y) âŸ©
          from Bâ‰²A (to Bâ‰²A y)
        â‰¡âŸ¨ fromâˆ˜to Bâ‰²A y âŸ©
          y
        âˆ}
    }
#+end_src

** Equational reasoning for embedding

#+begin_src agda2
module â‰²-Reasoning where

  infix  1 â‰²-begin_
  infixr 2 _â‰²âŸ¨_âŸ©_
  infix  3 _â‰²-âˆ

  â‰²-begin_ : âˆ€ {A B : Set}
    â†’ A â‰² B
      -----
    â†’ A â‰² B
  â‰²-begin Aâ‰²B = Aâ‰²B

  _â‰²âŸ¨_âŸ©_ : âˆ€ (A : Set) {B C : Set}
    â†’ A â‰² B
    â†’ B â‰² C
      -----
    â†’ A â‰² C
  A â‰²âŸ¨ Aâ‰²B âŸ© Bâ‰²C = â‰²-trans Aâ‰²B Bâ‰²C

  _â‰²-âˆ : âˆ€ (A : Set)
      -----
    â†’ A â‰² A
  A â‰²-âˆ = â‰²-refl
#+end_src

* Isomorhism implies an embedding
#+begin_src agda2
â‰ƒ-implies-â‰² : âˆ€ {A B : Set}
  â†’ A â‰ƒ B
    -----
  â†’ A â‰² B
â‰ƒ-implies-â‰² Aâ‰ƒB =
  record
    { to = to Aâ‰ƒB
      ; from = from Aâ‰ƒB
      ; fromâˆ˜to = fromâˆ˜to Aâ‰ƒB
      }
#+end_src

* Equivalence
** â‡” is iff or equivalence 
#+begin_src agda2
record _â‡”_ (A B : Set) : Set where
  field
    to : A â†’ B
    from : B â†’ A
open _â‡”_
#+end_src

So now to prove that equivalence is an equivalence relation
(it had better be eh?)

** â‡” is reflexive
#+begin_src agda2
â‡”-refl : {A : Set}
  â†’ A â‡” A
â‡”-refl =
  record
    { to = Î»{a â†’ a}
    ; from = Î»{b â†’ b}
    }
#+end_src

** â‡” is symmetric
#+begin_src agda2
â‡”-sym : {A B : Set}
  â†’ A â‡” B
    -----
  â†’ B â‡” A
â‡”-sym Aâ‡”B =
  record
    { to = from Aâ‡”B
    ; from = to Aâ‡”B
    }
#+end_src

** â‡” is transitive
#+begin_src agda2
â‡”-trans : {A B C : Set}
  â†’ A â‡” B
  â†’ B â‡” C
    ------
  â†’ A â‡” C
â‡”-trans Aâ‡”B Bâ‡”C =
  record
    { to = (to Bâ‡”C) âˆ˜ (to Aâ‡”B)
    ; from = (from Aâ‡”B) âˆ˜ (from Bâ‡”C)
    }
#+end_src


* References

#+print_bibliography:

* Footnotes

[fn:3] I'd like to see an exposition on this as I am deeply suspicious of
what seems to me an essentially non-constructive argument, it is
impossible to provide an inductive proof via =refl= without traversing
an infinite domain which is therefore non-computable. This is why we need a
non-inductive definition of identification via paths in HoTT and e.g.
cubical type theory.
[fn:2] From here on we adopt a "from-the-left" style of programming as
outlined in [cite:@mcbride-mckinna2004] there are good arguments for doing
this and Agda can use /innacessible patterns/ on the lhs for the required
fields [[https://agda.readthedocs.io/en/v2.6.4.2/language/function-definitions.html#dot-patterns][agda documentation on dot patterns]].

[fn:1] This is because an inductive definition of equality (the
identification type) relies on an intensional or defintional notion of
equality using the =refl= constructor. Since the domain of an arbitrary
function can be infinite, for example the natural numbers, there is no
constructive way to do this. 


